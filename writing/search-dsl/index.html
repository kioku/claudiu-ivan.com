<!doctype html><html lang=en><head><meta charset=utf-8><meta content="7 days" name=revisit-after><meta content="width=device-width,initial-scale=1" name=viewport><meta content="Claudiu Ivan develops software solutions that empower users and provide tangible value." name=description><meta content="Claudiu Ivan" name=author><meta content=XHtlMzh4rtF0BX73TQZtxFUtaDw3fBcDFNy7sJixems name=google-site-verification><meta content=B08B038A701BDB776D8BCC3BC84D5BD3 name=msvalidate.01><link href=https://github.com/kioku rel=me><link href=https://x.com/claudiuivan rel=me><link href=https://bsky.app/profile/claudiuivan.bsky.social rel=me><link href=https://hachyderm.io/@claudiuivan rel=me><link href=mailto:claudiu.ivan@me.com rel=me><link href=mailto:contact@claudiu-ivan.com rel=me><meta content="A Principled Approach to Querying Data | Claudiu Ivan" property=og:title><meta content="A Principled Approach to Querying Data | Claudiu Ivan" name=twitter:title><link href=https://claudiu-ivan.com/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=https://claudiu-ivan.com/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=https://claudiu-ivan.com/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><title>A Principled Approach to Querying Data | Claudiu Ivan</title><link href=https://cdn.simplecss.org/simple.min.css rel=stylesheet><link href=https://claudiu-ivan.com/style.css rel=stylesheet><body><nav><a href=https://claudiu-ivan.com>Home</a><a href=https://claudiu-ivan.com/writing>Writing</a></nav><main class=section><div class=container><h1 class=title>A Principled Approach to Querying Data</h1><p class=subtitle><strong>2025-02-06</strong><p>The rise of local-first web applications demands a rethinking of traditional client-server architectures. Users expect near-native responsiveness, even when offline. This necessitates efficient, client-side data processing, including search. The techniques presented in this article, while demonstrated in a generic context, are equally applicable to both local-first and server-side systems. We'll explore a type-driven approach, leveraging a Domain-Specific Language (DSL), to create a powerful and maintainable search system.<p>The complete code for this article is available as a <a href=https://gist.github.com/kioku/3350e4c4f1aac5d3f5f53e68923cb35a rel=noopener target=_blank>GitHub Gist</a>. It requires no external dependencies and can be run directly with Bun, Deno, or Node.js using the <code>--experimental-strip-types</code> flag.<h2 id=domain-specific-languages-dsls>Domain-Specific Languages (DSLs)</h2><p>Our approach centers around a DSL tailored to the specifics of searching "issues" – a common concept in project management and bug tracking. A DSL provides a specialized language for expressing search intent, offering several key advantages. Consider these example queries:<ul><li><code>is:open label:bug</code><li><code>author:alice (type:feature type:enhancement)</code><li><code>is:closed milestone:v1.0 assignee:bob</code></ul><p>The expressiveness and clarity of a well-designed Domain-Specific Language (DSL) are evident across many successful systems. Examples include Lucene/Elasticsearch, which utilizes a query string DSL for full-text search. SQL employs its <code>WHERE</code> clause as a DSL for filtering data, and GraphQL defines a query language for fetching data from APIs. The reader might observe the similarity of the proposed DSL to the one used by GitHub in their issue search functionality.<p>The benefits of using a DSL are multifaceted. It provides controlled complexity by limiting the scope of possible queries and ensures domain alignment by mirroring the domain's concepts in its vocabulary. This, in turn, enhances usability, allowing users to query using familiar terms. Furthermore, a formal grammar simplifies maintainability and extensibility, making modification and expansion more manageable.<h2 id=defining-the-domain>Defining the domain</h2><p>The structure of the dataset is usually inferred from the constraints of the business domain being modeled. In this case, we have chosen an issue tracking system, so the basic value we'll be working with is represented by the <code>Issue</code> interface.<pre class=language-typescript data-lang=typescript style=background:#282828;color:#fdf4c1aa><code class=language-typescript data-lang=typescript><span style=color:#fa5c4b>type </span><span style=color:#8ec07c>IssueStatus </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>'open' </span><span style=color:#fe8019>| </span><span style=color:#b8bb26>'closed'</span><span>;
</span><span style=color:#fa5c4b>type </span><span style=color:#8ec07c>IssueType </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>'bug' </span><span style=color:#fe8019>| </span><span style=color:#b8bb26>'feature' </span><span style=color:#fe8019>| </span><span style=color:#b8bb26>'docs' </span><span style=color:#fe8019>| </span><span style=color:#b8bb26>'enhancement'</span><span>;
</span><span>
</span><span style=color:#fa5c4b>interface </span><span style=color:#8ec07c>Issue </span><span>{
</span><span>  </span><span style=color:#fdf4c1>id</span><span style=color:#fe8019>: </span><span style=color:#fabd2f>string</span><span>;
</span><span>  </span><span style=color:#fdf4c1>title</span><span style=color:#fe8019>: </span><span style=color:#fabd2f>string</span><span>;
</span><span>  </span><span style=color:#fdf4c1>status</span><span style=color:#fe8019>: </span><span style=color:#8ec07c>IssueStatus</span><span>;
</span><span>  </span><span style=color:#fdf4c1>author</span><span style=color:#fe8019>: </span><span style=color:#fabd2f>string</span><span>;
</span><span>  </span><span style=color:#fdf4c1>labels</span><span style=color:#fe8019>: </span><span style=color:#fabd2f>string</span><span>[];
</span><span>  </span><span style=color:#fdf4c1>milestone</span><span style=color:#fe8019>: </span><span style=color:#fabd2f>string </span><span style=color:#fe8019>| </span><span style=color:#fabd2f>null</span><span>;
</span><span>  </span><span style=color:#fdf4c1>assignee</span><span style=color:#fe8019>: </span><span style=color:#fabd2f>string </span><span style=color:#fe8019>| </span><span style=color:#fabd2f>null</span><span>;
</span><span>  </span><span style=color:#fdf4c1>type</span><span style=color:#fe8019>: </span><span style=color:#8ec07c>IssueType</span><span>;
</span><span>  </span><span style=color:#fdf4c1>updatedAt</span><span style=color:#fe8019>: </span><span style=color:#fabd2f>number</span><span>;
</span><span>}
</span></code></pre><p>This is just <em>one example</em>. The same principles can be applied to many other domains: document management, customer relationship management, product lists, application logs, etc.<h2 id=error-handling>Error Handling</h2><p>Before we dive into parsing, we need a robust way to handle potential errors. The <code>Either</code> type, a cornerstone of functional programming, provides this mechanism. It is used to represent a value that can be the "success" (<code>Right</code> case) or the "failure" (<code>Left</code> case) of applying an operation.<pre class=language-typescript data-lang=typescript style=background:#282828;color:#fdf4c1aa><code class=language-typescript data-lang=typescript><span style=color:#fa5c4b>type </span><span style=color:#8ec07c>Either</span><span><</span><span style=color:#8ec07c>L</span><span>, </span><span style=color:#8ec07c>R</span><span>> </span><span style=color:#fe8019>= </span><span style=color:#8ec07c>Left</span><span><</span><span style=color:#8ec07c>L</span><span>> </span><span style=color:#fe8019>| </span><span style=color:#8ec07c>Right</span><span><</span><span style=color:#8ec07c>R</span><span>>;
</span><span>
</span><span style=color:#fa5c4b>class </span><span style=color:#8ec07c>Left</span><span><</span><span style=color:#8ec07c>L</span><span>> {
</span><span>  </span><span style=color:#fa5c4b>constructor</span><span>(</span><span style=color:#fa5c4b>readonly </span><span style=color:#fdf4c1>value</span><span style=color:#fe8019>: </span><span style=color:#8ec07c>L</span><span>) { }
</span><span>  </span><span style=color:#8ec07c>isLeft</span><span>()</span><span style=color:#fe8019>: </span><span style=color:#fdf4c1>this </span><span style=color:#fe8019>is </span><span style=color:#8ec07c>Left</span><span><</span><span style=color:#8ec07c>L</span><span>> { </span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>true</span><span>; }
</span><span>  </span><span style=color:#8ec07c>isRight</span><span>()</span><span style=color:#fe8019>: </span><span style=color:#fdf4c1>this </span><span style=color:#fe8019>is </span><span style=color:#8ec07c>Right</span><span><</span><span style=color:#fabd2f>never</span><span>> { </span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>false</span><span>; }
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>class </span><span style=color:#8ec07c>Right</span><span><</span><span style=color:#8ec07c>R</span><span>> {
</span><span>  </span><span style=color:#fa5c4b>constructor</span><span>(</span><span style=color:#fa5c4b>readonly </span><span style=color:#fdf4c1>value</span><span style=color:#fe8019>: </span><span style=color:#8ec07c>R</span><span>) { }
</span><span>  </span><span style=color:#8ec07c>isLeft</span><span>()</span><span style=color:#fe8019>: </span><span style=color:#fdf4c1>this </span><span style=color:#fe8019>is </span><span style=color:#8ec07c>Left</span><span><</span><span style=color:#fabd2f>never</span><span>> { </span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>false</span><span>; }
</span><span>  </span><span style=color:#8ec07c>isRight</span><span>()</span><span style=color:#fe8019>: </span><span style=color:#fdf4c1>this </span><span style=color:#fe8019>is </span><span style=color:#8ec07c>Right</span><span><</span><span style=color:#8ec07c>R</span><span>> { </span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>true</span><span>; }
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>const </span><span style=color:#8ec07c>success </span><span style=color:#fe8019>= </span><span><</span><span style=color:#8ec07c>T</span><span>>(</span><span style=color:#fdf4c1>value</span><span style=color:#fe8019>: </span><span style=color:#8ec07c>T</span><span>) </span><span style=color:#fa5c4b>=> new </span><span style=color:#8ec07c>Right</span><span>(</span><span style=color:#fdf4c1>value</span><span>);
</span><span style=color:#fa5c4b>const </span><span style=color:#8ec07c>failure </span><span style=color:#fe8019>= </span><span><</span><span style=color:#8ec07c>E</span><span>>(</span><span style=color:#fdf4c1>error</span><span style=color:#fe8019>: </span><span style=color:#8ec07c>E</span><span>) </span><span style=color:#fa5c4b>=> new </span><span style=color:#8ec07c>Left</span><span>(</span><span style=color:#fdf4c1>error</span><span>);
</span></code></pre><p>Throughout the program, we'll use <code>Either</code> to propagate results. If a parsing step succeeds, it returns a <code>Right</code> containing the parsed value and the remaining input. If it fails, it returns a <code>Left</code> containing an error object. This explicit error handling is crucial for building a reliable system.<h2 id=parsing-with-precision>Parsing with precision</h2><p>To process queries, we employ <a href=https://en.wikipedia.org/wiki/Parser_combinator rel=noopener target=_blank>parser combinators</a>. They are a powerful technique from functional programming, often used in compiler design, for building parsers in a modular, composable, and declarative way.<p>In essence, a parser combinator is a higher-order function: it takes one or more parsers as input and returns a <em>new</em> parser. Each parser attempts to match a portion of the input string. If successful, it returns a <code>Right</code> containing the parsed value and the remaining input string. If it fails, it returns a <code>Left</code> with an error.<pre class=language-typescript data-lang=typescript style=background:#282828;color:#fdf4c1aa><code class=language-typescript data-lang=typescript><span style=color:#fa5c4b>type </span><span style=color:#8ec07c>ParserError </span><span style=color:#fe8019>= </span><span>{
</span><span>  </span><span style=color:#fdf4c1>code</span><span style=color:#fe8019>: </span><span style=color:#b8bb26>'INVALID_TOKEN' </span><span style=color:#fe8019>| </span><span style=color:#b8bb26>'MISSING_VALUE' </span><span style=color:#fe8019>| </span><span style=color:#b8bb26>'INVALID_STATUS' </span><span style=color:#fe8019>| </span><span style=color:#b8bb26>'INVALID_TYPE' </span><span style=color:#fe8019>| </span><span style=color:#b8bb26>'INVALID_TIME_FILTER'</span><span>;
</span><span>  </span><span style=color:#fdf4c1>message</span><span style=color:#fe8019>: </span><span style=color:#fabd2f>string</span><span>;
</span><span>  </span><span style=color:#fdf4c1>position</span><span style=color:#fe8019>: </span><span style=color:#fabd2f>number</span><span>;
</span><span>  </span><span style=color:#fdf4c1>input</span><span style=color:#fe8019>: </span><span style=color:#fabd2f>string</span><span>;
</span><span>};
</span><span>
</span><span style=color:#fa5c4b>type </span><span style=color:#8ec07c>ParserResult</span><span><</span><span style=color:#8ec07c>T</span><span>> </span><span style=color:#fe8019>= </span><span style=color:#8ec07c>Either</span><span><</span><span style=color:#8ec07c>ParserError</span><span>, [</span><span style=color:#8ec07c>T</span><span>, </span><span style=color:#fabd2f>string</span><span>]>;
</span><span style=color:#fa5c4b>type </span><span style=color:#8ec07c>Parser</span><span><</span><span style=color:#8ec07c>T</span><span>> </span><span style=color:#fe8019>= </span><span>(</span><span style=color:#fdf4c1>input</span><span style=color:#fe8019>: </span><span style=color:#fabd2f>string</span><span>) </span><span style=color:#fa5c4b>=> </span><span style=color:#8ec07c>ParserResult</span><span><</span><span style=color:#8ec07c>T</span><span>>;
</span></code></pre><p>This implementation uses several fundamental combinators.<pre class=language-typescript data-lang=typescript style=background:#282828;color:#fdf4c1aa><code class=language-typescript data-lang=typescript><span style=font-style:italic;color:#928374>/** Matches a literal string. */
</span><span style=color:#fa5c4b>const </span><span style=color:#8ec07c>lit </span><span style=color:#fe8019>= </span><span>(</span><span style=color:#fdf4c1>match</span><span style=color:#fe8019>: </span><span style=color:#fabd2f>string</span><span>)</span><span style=color:#fe8019>: </span><span style=color:#8ec07c>Parser</span><span><</span><span style=color:#fabd2f>string</span><span>> </span><span style=color:#fa5c4b>=> </span><span>(</span><span style=color:#fdf4c1>input</span><span>) </span><span style=color:#fa5c4b>=> </span><span>{ </span><span style=color:#fe8019>... </span><span>};
</span><span>
</span><span style=font-style:italic;color:#928374>/** Parses a sequence of alphanumeric characters. */
</span><span style=color:#fa5c4b>const </span><span style=color:#8ec07c>word </span><span style=color:#fe8019>= </span><span>()</span><span style=color:#fe8019>: </span><span style=color:#8ec07c>Parser</span><span><</span><span style=color:#fabd2f>string</span><span>> </span><span style=color:#fa5c4b>=> </span><span>(</span><span style=color:#fdf4c1>input</span><span style=color:#fe8019>: </span><span style=color:#fabd2f>string</span><span>) </span><span style=color:#fa5c4b>=> </span><span>{ </span><span style=color:#fe8019>... </span><span>};
</span><span>
</span><span style=font-style:italic;color:#928374>/**
</span><span style=font-style:italic;color:#928374> * Tries multiple parsers in sequence, returning the result of the first one that succeeds.
</span><span style=font-style:italic;color:#928374> * This allows for choices in the grammar (e.g., `is:open` OR `is:closed`).
</span><span style=font-style:italic;color:#928374> */
</span><span style=color:#fa5c4b>const </span><span style=color:#8ec07c>alt </span><span style=color:#fe8019>= </span><span><</span><span style=color:#8ec07c>T</span><span>>(</span><span style=color:#fe8019>...</span><span style=color:#fdf4c1>parsers</span><span style=color:#fe8019>: </span><span style=color:#8ec07c>Parser</span><span><</span><span style=color:#8ec07c>T</span><span>>[])</span><span style=color:#fe8019>: </span><span style=color:#8ec07c>Parser</span><span><</span><span style=color:#8ec07c>T</span><span>> </span><span style=color:#fa5c4b>=> </span><span>(</span><span style=color:#fdf4c1>input</span><span>) </span><span style=color:#fa5c4b>=> </span><span>{ </span><span style=color:#fe8019>... </span><span>};
</span><span>
</span><span style=font-style:italic;color:#928374>/**
</span><span style=font-style:italic;color:#928374> * Applies multiple parsers sequentially, succeeding only if *all* of them succeed.
</span><span style=font-style:italic;color:#928374> * This is used to build up complex structures from simpler parts (e.g., `is:` followed by `open`).
</span><span style=font-style:italic;color:#928374> */
</span><span style=color:#fa5c4b>const </span><span style=color:#8ec07c>seq </span><span style=color:#fe8019>= </span><span><</span><span style=color:#8ec07c>T </span><span style=color:#fa5c4b>extends </span><span style=color:#fabd2f>unknown</span><span>[]>(</span><span style=color:#fe8019>...</span><span style=color:#fdf4c1>parsers</span><span style=color:#fe8019>: </span><span>{ [</span><span style=color:#8ec07c>K </span><span style=color:#fe8019>in keyof </span><span style=color:#8ec07c>T</span><span>]</span><span style=color:#fe8019>: </span><span style=color:#8ec07c>Parser</span><span><</span><span style=color:#8ec07c>T</span><span>[</span><span style=color:#8ec07c>K</span><span>]> })</span><span style=color:#fe8019>: </span><span style=color:#8ec07c>Parser</span><span><</span><span style=color:#8ec07c>T</span><span>> </span><span style=color:#fa5c4b>=> </span><span>(</span><span style=color:#fdf4c1>input</span><span>) </span><span style=color:#fa5c4b>=> </span><span>{ </span><span style=color:#fe8019>... </span><span>};
</span><span>
</span><span style=font-style:italic;color:#928374>/** Applies a parser zero or more times, collecting the results into an array. */
</span><span style=color:#fa5c4b>const </span><span style=color:#8ec07c>many </span><span style=color:#fe8019>= </span><span><</span><span style=color:#8ec07c>T</span><span>>(</span><span style=color:#fdf4c1>parser</span><span style=color:#fe8019>: </span><span style=color:#8ec07c>Parser</span><span><</span><span style=color:#8ec07c>T</span><span>>)</span><span style=color:#fe8019>: </span><span style=color:#8ec07c>Parser</span><span><</span><span style=color:#8ec07c>T</span><span>[]> </span><span style=color:#fa5c4b>=> </span><span>(</span><span style=color:#fdf4c1>input</span><span style=color:#fe8019>: </span><span style=color:#fabd2f>string</span><span>) </span><span style=color:#fa5c4b>=> </span><span>{ </span><span style=color:#fe8019>... </span><span>};
</span><span>
</span><span style=font-style:italic;color:#928374>/** Transforms the result of a successful parse using a provided function. Required to build the AST. */
</span><span style=color:#fa5c4b>const </span><span style=color:#8ec07c>map </span><span style=color:#fe8019>= </span><span><</span><span style=color:#8ec07c>T</span><span>, </span><span style=color:#8ec07c>U</span><span>>(</span><span style=color:#fdf4c1>parser</span><span style=color:#fe8019>: </span><span style=color:#8ec07c>Parser</span><span><</span><span style=color:#8ec07c>T</span><span>>, </span><span style=color:#8ec07c>fn</span><span style=color:#fe8019>: </span><span>(</span><span style=color:#fdf4c1>value</span><span style=color:#fe8019>: </span><span style=color:#8ec07c>T</span><span>) </span><span style=color:#fa5c4b>=> </span><span style=color:#8ec07c>U</span><span>)</span><span style=color:#fe8019>: </span><span style=color:#8ec07c>Parser</span><span><</span><span style=color:#8ec07c>U</span><span>> </span><span style=color:#fa5c4b>=> </span><span>(</span><span style=color:#fdf4c1>input</span><span>) </span><span style=color:#fa5c4b>=> </span><span>{ </span><span style=color:#fe8019>... </span><span>};
</span></code></pre><p>We start with simple parsers (like <code>lit</code> and <code>word</code>) and combine them using combinators like <code>seq</code>, <code>alt</code>, and <code>many</code> to build increasingly complex parsers. The <code>map</code> combinator is crucial for transforming the raw parsed strings into a more structured representation – our Abstract Syntax Tree. This recursive nature of building complex structures from simpler ones is a hallmark of functional programming.<p>Composition is amazing. It's remarkable what unexpected elegance emerges from combining simple elements. In this simplicity lies the beauty of parser combinators.<h2 id=structuring-the-query>Structuring the query</h2><p>The responsibility of the parser, is not to directly execute the query, it is to transform the input string into an Abstract Syntax Tree (AST). The AST is a structured, hierarchical representation of the query, independent of its specific syntax. This decoupling is essential for several reasons:<ol><li><strong>Separation of Concerns:</strong> Parsing (syntax) is separated from evaluation (semantics).<li><strong>Optimization:</strong> The AST can be analyzed and optimized before execution.<li><strong>Flexibility:</strong> The AST can be used for multiple purposes (e.g., generating queries for different backends).</ol><pre class=language-typescript data-lang=typescript style=background:#282828;color:#fdf4c1aa><code class=language-typescript data-lang=typescript><span style=color:#fa5c4b>type </span><span style=color:#8ec07c>FilterNodeType </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>'status' </span><span style=color:#fe8019>| </span><span style=color:#b8bb26>'author' </span><span style=color:#fe8019>| </span><span style=color:#b8bb26>'label' </span><span style=color:#fe8019>| </span><span style=color:#b8bb26>'type' </span><span style=color:#fe8019>| </span><span style=color:#b8bb26>'updated' </span><span style=color:#fe8019>| </span><span style=color:#b8bb26>'and' </span><span style=color:#fe8019>| </span><span style=color:#b8bb26>'or'</span><span>;
</span><span>
</span><span style=color:#fa5c4b>type </span><span style=color:#8ec07c>LeafFilterNode </span><span style=color:#fe8019>= </span><span>{
</span><span>  </span><span style=color:#fa5c4b>readonly </span><span style=color:#fdf4c1>type</span><span style=color:#fe8019>: </span><span style=color:#8ec07c>FilterNodeType</span><span>;
</span><span>  </span><span style=color:#fa5c4b>readonly </span><span style=color:#fdf4c1>value</span><span style=color:#fe8019>: </span><span style=color:#fabd2f>string</span><span>;
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>type </span><span style=color:#8ec07c>FilterNode </span><span style=color:#fe8019>= </span><span style=color:#8ec07c>LeafFilterNode </span><span style=color:#fe8019>| </span><span>{
</span><span>  </span><span style=color:#fdf4c1>type</span><span style=color:#fe8019>: </span><span style=color:#b8bb26>'and' </span><span style=color:#fe8019>| </span><span style=color:#b8bb26>'or'</span><span>;
</span><span>  </span><span style=color:#fdf4c1>value</span><span style=color:#fe8019>: </span><span style=color:#8ec07c>FilterNode</span><span>[];
</span><span>};
</span></code></pre><p>The AST consists of <code>FilterNode</code> objects. Leaf nodes (<code>LeafFilterNode</code>) represent individual filters (e.g., <code>status:open</code>), while <code>and</code> / <code>or</code> nodes represent boolean combinations.<p>The final <code>searchQueryParser</code> is obtained by composing the combinators.<pre class=language-typescript data-lang=typescript style=background:#282828;color:#fdf4c1aa><code class=language-typescript data-lang=typescript><span style=color:#fa5c4b>const </span><span style=color:#fdf4c1>searchQueryParser</span><span style=color:#fe8019>: </span><span style=color:#8ec07c>Parser</span><span><</span><span style=color:#8ec07c>FilterNode</span><span>> </span><span style=color:#fe8019>= </span><span style=color:#8ec07c>map</span><span>(
</span><span>  </span><span style=color:#8ec07c>many</span><span>(</span><span style=color:#8ec07c>alt</span><span>(</span><span style=color:#fdf4c1>statusParser</span><span>, </span><span style=color:#fdf4c1>authorParser</span><span>, </span><span style=color:#fdf4c1>labelParser</span><span>, </span><span style=color:#fdf4c1>typeParser</span><span>, </span><span style=color:#fdf4c1>timeFilterParser</span><span>, </span><span style=color:#fdf4c1>orParser</span><span>)),
</span><span>  (</span><span style=color:#fdf4c1>filters</span><span>) </span><span style=color:#fa5c4b>=> </span><span>{ </span><span style=color:#fe8019>... </span><span>}
</span><span>);
</span></code></pre><p>While the individual filter parsers like <code>statusParser</code> are defined as follows.<pre class=language-typescript data-lang=typescript style=background:#282828;color:#fdf4c1aa><code class=language-typescript data-lang=typescript><span style=color:#fa5c4b>const </span><span style=color:#fdf4c1>statusParser </span><span style=color:#fe8019>= </span><span style=color:#8ec07c>map</span><span>(
</span><span>  </span><span style=color:#8ec07c>seq</span><span>(</span><span style=color:#8ec07c>lit</span><span>(</span><span style=color:#b8bb26>'is:'</span><span>), </span><span style=color:#8ec07c>alt</span><span>(</span><span style=color:#8ec07c>lit</span><span>(</span><span style=color:#b8bb26>'open'</span><span>), </span><span style=color:#8ec07c>lit</span><span>(</span><span style=color:#b8bb26>'closed'</span><span>))),
</span><span>  ([</span><span style=color:#fdf4c1>_</span><span>, </span><span style=color:#fdf4c1>status</span><span>]) </span><span style=color:#fa5c4b>=> </span><span>({ type: </span><span style=color:#b8bb26>'status'</span><span>, value: </span><span style=color:#fdf4c1>status </span><span>} </span><span style=color:#fa5c4b>as const</span><span>)
</span><span>);
</span></code></pre><h2 id=evaluating-the-query>Evaluating the query</h2><p>With the AST in hand, we can transform it into a <em>predicate function</em>.<pre class=language-typescript data-lang=typescript style=background:#282828;color:#fdf4c1aa><code class=language-typescript data-lang=typescript><span style=color:#fa5c4b>type </span><span style=color:#8ec07c>IssuePredicate </span><span style=color:#fe8019>= </span><span>(</span><span style=color:#fdf4c1>issue</span><span style=color:#fe8019>: </span><span style=color:#8ec07c>Issue</span><span>) </span><span style=color:#fa5c4b>=> </span><span style=color:#fabd2f>boolean</span><span>;
</span></code></pre><p>We define predicate-building functions for each filter type, including input validation.<pre class=language-typescript data-lang=typescript style=background:#282828;color:#fdf4c1aa><code class=language-typescript data-lang=typescript><span style=color:#fa5c4b>const </span><span style=color:#8ec07c>isValidIssueStatus </span><span style=color:#fe8019>= </span><span>(</span><span style=color:#fdf4c1>value</span><span style=color:#fe8019>: </span><span style=color:#fabd2f>string</span><span>)</span><span style=color:#fe8019>: </span><span style=color:#fdf4c1>value </span><span style=color:#fe8019>is </span><span style=color:#8ec07c>IssueStatus </span><span style=color:#fa5c4b>=> </span><span>{
</span><span>  </span><span style=color:#fa5c4b>return </span><span>[</span><span style=color:#b8bb26>'open'</span><span>, </span><span style=color:#b8bb26>'closed'</span><span>]</span><span style=color:#fdf4c1>.</span><span style=color:#8ec07c>includes</span><span>(</span><span style=color:#fdf4c1>value</span><span>);
</span><span>};
</span><span style=color:#fa5c4b>const </span><span style=color:#8ec07c>matchStatus </span><span style=color:#fe8019>= </span><span>(</span><span style=color:#fdf4c1>status</span><span style=color:#fe8019>: </span><span style=color:#fabd2f>string</span><span>)</span><span style=color:#fe8019>: </span><span style=color:#8ec07c>IssuePredicate </span><span style=color:#fa5c4b>=> </span><span>{
</span><span>  </span><span style=color:#fa5c4b>if </span><span>(</span><span style=color:#8ec07c>isValidIssueStatus</span><span>(</span><span style=color:#fdf4c1>status</span><span>)) {
</span><span>    </span><span style=color:#fa5c4b>return </span><span>(</span><span style=color:#fdf4c1>issue</span><span>) </span><span style=color:#fa5c4b>=> </span><span style=color:#fdf4c1>issue</span><span>.</span><span style=color:#fabd2f>status </span><span style=color:#fe8019>=== </span><span style=color:#fdf4c1>status</span><span>;
</span><span>  }
</span><span>  </span><span style=color:#8ec07c>console</span><span style=color:#fdf4c1>.</span><span style=color:#fabd2f>error</span><span>(</span><span style=color:#b8bb26>`Invalid status: ${</span><span style=color:#fdf4c1>status</span><span style=color:#b8bb26>}`</span><span>);
</span><span>  </span><span style=color:#fa5c4b>return </span><span style=color:#8ec07c>matchNone</span><span>();
</span><span>};
</span><span>
</span><span style=font-style:italic;color:#928374>// ... similar functions each filter type
</span></code></pre><p>The <code>createPredicate</code> function recursively traverses the AST, creating and combining predicates.<pre class=language-typescript data-lang=typescript style=background:#282828;color:#fdf4c1aa><code class=language-typescript data-lang=typescript><span style=color:#fa5c4b>const </span><span style=color:#8ec07c>createPredicate </span><span style=color:#fe8019>= </span><span>(</span><span style=color:#fdf4c1>node</span><span style=color:#fe8019>: </span><span style=color:#8ec07c>FilterNode</span><span>)</span><span style=color:#fe8019>: </span><span style=color:#8ec07c>IssuePredicate </span><span style=color:#fa5c4b>=> </span><span>{
</span><span>  </span><span style=color:#fa5c4b>switch </span><span>(</span><span style=color:#fdf4c1>node</span><span>.</span><span style=color:#fabd2f>type</span><span>) {
</span><span>    </span><span style=color:#fa5c4b>case </span><span style=color:#b8bb26>'status'</span><span>:
</span><span>      </span><span style=color:#fa5c4b>return </span><span style=color:#8ec07c>isValidIssueStatus</span><span>(</span><span style=color:#fdf4c1>node</span><span>.</span><span style=color:#fabd2f>value</span><span>) </span><span style=color:#fe8019>? </span><span style=color:#8ec07c>matchStatus</span><span>(</span><span style=color:#fdf4c1>node</span><span>.</span><span style=color:#fabd2f>value</span><span>) </span><span style=color:#fe8019>: </span><span style=color:#8ec07c>matchNone</span><span>();
</span><span>    </span><span style=font-style:italic;color:#928374>// ... other cases
</span><span>    </span><span style=color:#fa5c4b>case </span><span style=color:#b8bb26>'and'</span><span>:
</span><span>      </span><span style=color:#fa5c4b>return </span><span style=color:#8ec07c>and</span><span>(</span><span style=color:#fe8019>...</span><span>(</span><span style=color:#fdf4c1>node</span><span>.</span><span style=color:#fabd2f>value </span><span style=color:#fa5c4b>as </span><span style=color:#8ec07c>FilterNode</span><span>[])</span><span style=color:#fdf4c1>.</span><span style=color:#8ec07c>map</span><span>(</span><span style=color:#fdf4c1>createPredicate</span><span>));
</span><span>    </span><span style=font-style:italic;color:#928374>// ...
</span><span>  }
</span><span>};
</span><span>
</span><span style=color:#fa5c4b>const </span><span style=color:#8ec07c>and </span><span style=color:#fe8019>= </span><span>(</span><span style=color:#fe8019>...</span><span style=color:#fdf4c1>preds</span><span style=color:#fe8019>: </span><span style=color:#8ec07c>IssuePredicate</span><span>[])</span><span style=color:#fe8019>: </span><span style=color:#8ec07c>IssuePredicate </span><span style=color:#fa5c4b>=>
</span><span>  (</span><span style=color:#fdf4c1>issue</span><span>) </span><span style=color:#fa5c4b>=> </span><span style=color:#fdf4c1>preds.</span><span style=color:#8ec07c>every</span><span>(</span><span style=color:#fdf4c1>p </span><span style=color:#fa5c4b>=> </span><span style=color:#8ec07c>p</span><span>(</span><span style=color:#fdf4c1>issue</span><span>));
</span></code></pre><p>This recursive structure elegantly handles complex boolean logic that will be applied to the dataset.<h2 id=query-execution>Query execution</h2><p>We define an <code>executeQuery</code> function to orchestrate the entire process.<pre class=language-typescript data-lang=typescript style=background:#282828;color:#fdf4c1aa><code class=language-typescript data-lang=typescript><span style=color:#fa5c4b>const </span><span style=color:#8ec07c>executeQuery </span><span style=color:#fe8019>= </span><span>(</span><span style=color:#fdf4c1>query</span><span style=color:#fe8019>: </span><span style=color:#fabd2f>string</span><span>, </span><span style=color:#fdf4c1>issues</span><span style=color:#fe8019>: </span><span style=color:#8ec07c>Issue</span><span>[])</span><span style=color:#fe8019>: </span><span style=color:#8ec07c>Issue</span><span>[] </span><span style=color:#fa5c4b>=> </span><span>{
</span><span>  </span><span style=color:#fa5c4b>const </span><span style=color:#fdf4c1>parsedQuery </span><span style=color:#fe8019>= </span><span style=color:#8ec07c>searchQueryParser</span><span>(</span><span style=color:#fdf4c1>query</span><span>);
</span><span>
</span><span>  </span><span style=color:#fa5c4b>if </span><span>(</span><span style=color:#fdf4c1>parsedQuery.</span><span style=color:#8ec07c>isLeft</span><span>()) {
</span><span>    </span><span style=color:#8ec07c>console</span><span style=color:#fdf4c1>.</span><span style=color:#fabd2f>error</span><span>(</span><span style=color:#b8bb26>`Parse Error: ${</span><span style=color:#fdf4c1>parsedQuery</span><span style=color:#b8bb26>.</span><span style=color:#fabd2f>value</span><span style=color:#b8bb26>.</span><span style=color:#fdf4c1>message</span><span style=color:#b8bb26>}`</span><span>);
</span><span>    </span><span style=color:#fa5c4b>return </span><span>[]; </span><span style=font-style:italic;color:#928374>// Return empty array on parse failure
</span><span>  }
</span><span>
</span><span>  </span><span style=color:#fa5c4b>const </span><span style=color:#fdf4c1>ast </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>parsedQuery</span><span>.</span><span style=color:#fabd2f>value</span><span>[</span><span style=color:#d3869b>0</span><span>];
</span><span>  </span><span style=color:#fa5c4b>const </span><span style=color:#fdf4c1>predicate </span><span style=color:#fe8019>= </span><span style=color:#8ec07c>createPredicate</span><span>(</span><span style=color:#fdf4c1>ast</span><span>);
</span><span>  </span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>issues.</span><span style=color:#8ec07c>filter</span><span>(</span><span style=color:#fdf4c1>predicate</span><span>);
</span><span>};
</span></code></pre><p>The body of the function gracefully handles parsing errors, returning an empty result set and logging the error. In a production system, this error could be logged and surfaced through a variety of mechanisms, depending on the context.<h2 id=the-path-forward>The path forward</h2><p>It could be argued that other solutions might be more adequate for large datasets. For example, IndexedDB or SQLite could be used for data storage and querying. However, this does not negate the value of the techniques presented here. A database solution can be used as the storage layer, while the methods described in this article can be used to construct queries from the input of the system.<p>With that in mind, we should examine the performance of this system and explore potential improvements. Using the provided helper utilities within the linked code, a superficial performance evaluation was conducted. The following results were obtained on a test machine using a simulated dataset of 1 million issues.<pre class=language-plaintext data-lang=plaintext style=background:#282828;color:#fdf4c1aa><code class=language-plaintext data-lang=plaintext><span>Search Results for: "is:open"
</span><span>----------------------------------------
</span><span>Matching issues: 499344
</span><span>Search time: 20.77ms
</span><span>
</span><span>Search Results for: "is:closed"
</span><span>----------------------------------------
</span><span>Matching issues: 500656
</span><span>Search time: 20.06ms
</span><span>
</span><span>Search Results for: "is:open label:bug"
</span><span>----------------------------------------
</span><span>Matching issues: 210988
</span><span>Search time: 76.44ms
</span><span>
</span><span>Search Results for: "author:alice type:feature"
</span><span>----------------------------------------
</span><span>Matching issues: 63052
</span><span>Search time: 67.80ms
</span><span>
</span><span>Search Results for: "label:documentation type:docs"
</span><span>----------------------------------------
</span><span>Matching issues: 105336
</span><span>Search time: 52.06ms
</span><span>
</span><span>Search Results for: "is:open (author:charlie author:alice) label:enhancement"
</span><span>----------------------------------------
</span><span>Matching issues: 105326
</span><span>Search time: 81.30ms
</span></code></pre><p>These results indicate that the system can handle a decent number of records and execute queries with acceptable performance. However, it's important to recognize that the current implementation relies on a linear scan.<p>Therefore, for real-world applications dealing with intrinsic or imposed constraints, indexing becomes essential to maintain acceptable performance. A common choice for text fields, such as <code>title</code>, is an inverted index, which maps words to the IDs of the issues containing them. For other fields, simpler map-based indexes may suffice.<p>Beyond indexing, several other optimizations can be applied:<ul><li><strong>Query Optimization:</strong> Analyzing the AST to determine the most efficient order to apply filters. For example, applying the most selective filters (those that are likely to eliminate the most issues) first can significantly reduce the workload.<li><strong>Query Planning:</strong> In more complex scenarios, a query planner could choose between different indexes and execution strategies based on the query structure and data statistics.<li><strong>Caching</strong> can be applied at multiple levels: <ul><li><strong>Parsed Queries:</strong> Caching the AST for frequently used queries avoids repeated parsing.<li><strong>Predicates:</strong> Caching the generated predicate function can also save computation.<li><strong>Query Results:</strong> Caching the results of entire queries can be beneficial if the data doesn't change frequently.</ul></ul><p>These optimizations can provide a path forward for scaling the system to handle a large amount of data and complex queries, and their implementation is left as an exercise for the reader.<h2 id=conclusion>Conclusion</h2><p>This article has demonstrated a type-driven, functional approach to building a search DSL. We have leveraged TypeScript, functional parser combinators, and an AST to create a system that is not only functional but also clear, robust, and maintainable.<p>It's worth mentioning that the <code>Either</code> type is an example of a <em>monad</em> – a fundamental concept in functional programming. Monads provide a way to structure computations that involve sequencing operations and handling potential failures or side effects. While a deep dive into monad theory is beyond the scope of this article, recognizing this connection can open doors to a deeper understanding of functional programming principles, and maybe even lessen the barries of entry.<p>The techniques presented here provide a solid foundation for building sophisticated search capabilities in a variety of applications, from local-first web apps to server-side systems. By embracing these principles, developers can create search experiences that are both powerful and user-friendly.<h2 id=references-and-further-reading>References and Further Reading</h2><ul><li><a href=https://www.cs.nott.ac.uk/~pszgmh/pearl.pdf rel=noopener target=_blank>Functional Parsing</a> by Graham Hutton and Erik Meijer<li><a href=https://www.microsoft.com/en-us/research/publication/parsec-direct-style-monadic-parser-combinators-for-the-real-world/ rel=noopener target=_blank>Parsec: Direct Style Monadic Parser Combinators For The Real World</a> by Daan Leijen and Erik Meijer<li><a href=https://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf rel=noopener target=_blank>Monads for Functional Programming</a> by Philip Wadler<li><a href=http://learnyouahaskell.com/a-fistful-of-monads rel=noopener target=_blank>Learn You a Haskell for Great Good!</a> (Chapter on Monads)<li><a href=https://martinfowler.com/books/dsl.html rel=noopener target=_blank>Domain-Specific Languages</a> by Martin Fowler<li><a href=https://www.inkandswitch.com/local-first/ rel=noopener target=_blank>Local-first software: You own your data, in spite of the cloud</a> by Martin Kleppmann et al.</ul></div></main><footer><p>© 2025 Claudiu Ivan</footer><script async data-goatcounter=https://kioku.goatcounter.com/count src=//gc.zgo.at/count.js></script>